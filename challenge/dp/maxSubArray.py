
"""
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
"""


class Solution:

    T_T = '''
    
    '''

    N_K = """
    动态规划： 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解
    
    多阶段决策问题：如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，
    常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。

    基本思想：动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，
    然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。
    若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，
    而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案
    。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路
    
    基本模型：
        (1)确定问题的决策对象。
        (2)对决策过程划分阶段。 
        (3)对各阶段确定状态变量。 
        (4)根据状态变量确定费用函数和目标函数。 
        (5)建立各阶段状态变量的转移过程，确定状态转移方程。
        
    适用条件:
        1. 最优化原理
        2. 无后效性
        3. 子问题重叠性 :动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。'
        其中的关键在于解决冗余，这是动态规划算法的根本目的。因为需要存储空间状态，所以也是以空间换取时间
    """

    def maxSubArray(self, nums):
        """

        :param nums:
        :return:
        """
        ans = nums[0]
        sum = 0
        # cnt = 0
        for num in nums:

            # 专注 20min内搞定
            if sum > 0:
                # sum大于0，可以与后面的元素加和做比较
                sum += num

            else:
                # sum小于零，无加和效果，舍弃
                sum = num

            if sum > ans:
                ans = sum

        return ans

class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 贪心
        # max_sub = nums[-1]
        # sub = 0 
        # for _ in nums: 
        #     sub += _ 
        #     if max_sub < sub:
        #         max_sub = sub
        #     if sub < 0: 
        #         sub = 0 
        # return max_sub

        # dp
        for i in range(1, len(nums)):
            if nums[i-1] > 0: 
                nums[i] += nums[i-1]
        
        return max(nums)


if __name__ == '__main__':

    S = Solution()
    l = [-2, 1]
    ans = S.maxSubArray(l)
    print(ans)
